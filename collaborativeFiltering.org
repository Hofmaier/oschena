* Baseline Predictor
Es wird einfach der mean aller wertungen berechnen. mal sehen ob ich diese baseline verbessern kann.

* User-based
User base filtering sucht nach user, die aehnlich sind. 
Die Technik um aehnliche User zu finden heisst kNN. k neirest neighbors.
[[http://elehack.net/research/pubs/cf-survey/cf-survey.pdf][collaborative fitering recommendations]]
** Nearest neighbor
Es wird eine neighborhood N fuer einen user u erstellt.
*** Euclidean distance
ich verwende die squared euclidien distance
ein beispiel
[1,2,3] [2,4,6] = 14

*** Pearson Similarity
Um zwei User miteinander zu vergleichen, kann die Pearson Similarity eingesetzt werden.
Was passiert mit User die keine gemeinschaftlichen Item gerated haben? 
Wenn es keinen User gibt, der das selbe Item bewertet hat, ist der Korrelationskoeffizient -1.
Die Pearson Similarity beruecksichtigt nur gemeinsam geratete Daten.
Was passiert wenn zwei User ein einziges gemeinsames Item haben und dieses gleich bewerten?
Dann zeigt der Pearson Correlation Coffezient eine hohe Aehnlichkeit an.
*** Beispieldaten

| item | rating u1 | rating u2 |
|------+-----------+-----------|
|    1 |        43 |        99 |
|    2 |        21 |        65 |
|    3 |        25 |        79 |
|    4 |        42 |        75 |
|    5 |        57 |        87 |
|    6 |        59 |        81 |

2868 / 5413.27 = 0.529809

3,5,5,1,4
5,5,4,1,2
0.641503

2,3,4,5,5
1,2,3,4,4
-1

1,2,3,4,5
5,4,3,2,1
-1

* Data
[[http://files.grouplens.org/datasets/movielens/ml-100k-README.txt][movielens 100k ratings set readme]]
[[http://files.grouplens.org/datasets/movielens/ml-100k.zip][movielens 100k ratings zip file]]
Daten in u.data sind in Kolonnen strukturiert. 
Erste Kolonne user id, zweite item.id, dritte rating, vierte timestamp
u1.base hat 80000 ratings.
* Haskell
[[http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf]]

- IO Action :: Type und typeconstructor. Hat
- Functor :: ist eine Typeclass. Forder mapf. Ueber diese Struktur kann gemappt werden. can be mapped over.
- Applicative functors :: Normale Funktionen koennen auf zwei Funktoren angewandt werden. Resultat ist ein Funktor.
- Value contstructor :: ZipList ist ein value constructor.
- Type constructor :: list[] ist ein type constructor
- Monoid :: mappend nimmt zwei Monoids und gibt wieder einen zurueck. Es gibt einen Identity Element und Monoids sind assoziativ.
- Type class :: Type classes definieren Funktionen, fuer Instanzen einer Type class. Instanzen werden mit type construktoren gemacht. Stellen ein Interface dar.
- Type variable :: Kommt in der type class Definition vor.

** Types
Types werden mit data definiert. Ein Type hat Values. Values werden in der Typedefinition mit Constructors definiert
** Constructor
Ein Constructor ist eine Funktion. Der Constructor hat einen Bezeichner und optional Parameter die als Typen angegeben werden.
** Type constructor
** Type parameter
Ein type kann einen typeparamter haben. Dieser wird in der Funktionsdefinition definiert oder vom konkreten value abgeleitet.
** Typeclasses
** Type constructor

Nimmt einen type als Parameter.
** Monoid
** Functor
** Warum Haskell
- Fehler werden frueh erkannt
- weniger code
- concurrency und parallel processing kann einfach genutzt werden
 - eignet sich fuer analyse, modellierung, simulation
* Evaluation
- movielens data set hat 5 training test paare. u1.base - u1.test. 
- training/test ration = x = 80000/20000
- ich verwende eine accuracy metric. den mean absolute error mae.

* vorgehen
** TODO similarity fuer 2 user
** TODO similirity fuer 1 user
gib eine liste von allen similarities aus tupel (similarity, user)

* Probleme
- ich habe eine dictionary. key sind user. values sind dictionaries mit items als keys und ratings als values
